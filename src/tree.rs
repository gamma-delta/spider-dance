use schemars::JsonSchema;
use serde::{Deserialize, Serialize};

use unicode_width::UnicodeWidthStr;

use std::iter;

use crate::DrawOptions;

#[derive(Debug, Default, Deserialize, Serialize, JsonSchema)]
#[serde(default)]
pub struct Node {
    pub name: String,
    pub properties: Vec<String>,
    pub daughters: Vec<Node>,
    pub realized: Option<String>,
}

impl Node {
    // To draw a tree:
    // - Find out the number of terminal nodes
    // - Draw those spaced out evenly
    // -

    pub fn draw(&self, options: &DrawOptions) -> String {
        let pd = self.draw_partial(options, 0, 0.0);

        format!(
            r#"<svg xmlns="http://www.w3.org/2000/svg" version="1.1" width="{}" height="{}" viewBox="{} {} {} {}">
<!-- 
    This file was generated by Spider Dance v{}.
-->
<style>
    text {{
        font-family: 'Courier New', Courier, monospace;
        text-anchor: middle;
    }}

    #name {{
        font-size: 50px;
        color: black;
        font-weight: bold;
    }}

    #branch {{
        stroke-width: 20px;
    }}
</style>

{}
</svg>"#,
            pd.max_x,
            pd.max_y,
            -options.x_space,
            -options.y_space,
            pd.max_x + options.x_space * 2.0,
            pd.max_y + options.y_space * 2.0,
            env!("CARGO_PKG_VERSION"),
            pd.content
        )
    }

    fn draw_partial(
        &self,
        options: &DrawOptions,
        mut left_leaves: usize,
        depth: f32,
    ) -> PartialDraw {
        let bottom = depth
            + options.y_space
            + options.property_space * self.properties.len() as f32
            + if self.realized.is_some() {
                options.property_space
            } else {
                0.0
            };

        let (children, xpos) = if self.daughters.is_empty() {
            // OK, I'm a terminal node!
            left_leaves += 1;
            (vec![], (left_leaves - 1) as f32 * options.x_space)
        } else {
            let children: Vec<_> = self
                .daughters
                .iter()
                .map(|daughter| {
                    let pd = daughter.draw_partial(&options, left_leaves, bottom);
                    left_leaves = pd.left_leaves;
                    pd
                })
                .collect();
            let xpos = (children.first().map_or(0.0, |d| d.xpos)
                + children.last().map_or(0.0, |d| d.xpos))
                / 2.0;
            (children, xpos)
        };

        let inner_content = children
            .iter()
            .map(|d| {
                format!(
                    r#"
<line class="branch" x1="{}" x2="{}" y1="{}" y2="{}" stroke="{}"/>
{}"#,
                    xpos,
                    d.xpos,
                    bottom - options.y_space + options.property_space / 2.0,
                    d.ypos - options.node_font_size,
                    &options.branch_color,
                    d.content.as_str()
                )
            })
            .collect::<Vec<_>>();
        let inner_content = inner_content.concat();

        // Wrap my content around it
        let mut content = format!(
            r#"<g class="node">
    <text class="name" font-size="{}px" x="{}" y="{}">{}</text>"#,
            options.node_font_size, xpos, depth, &self.name,
        );
        if !self.properties.is_empty() {
            // Draw braces
            let max_cols = self
                .properties
                .iter()
                .map(|prop| UnicodeWidthStr::width(prop.as_str()))
                .max()
                .unwrap();
            let offset = max_cols as f32 * options.node_font_size / 3.0;

            let left_outer = xpos - offset - options.node_font_size / 2.0;
            let left_inner = xpos - offset;
            let right_outer = xpos + offset + options.node_font_size / 2.0;
            let right_inner = xpos + offset;
            let top = depth + options.property_space / 3.5;
            let bottom = depth + options.property_space * (self.properties.len() as f32 + 0.3);

            content.push_str(&format!(
                r#"<polyline class="bracket" fill="none" stroke="{}" points="{},{} {},{} {},{} {},{}" />
"#,
                options.branch_color,
                left_inner, top,
                left_outer, top,
                left_outer, bottom,
                left_inner, bottom,
            ));
            content.push_str(&format!(
                r#"<polyline class="bracket" fill="none" stroke="{}" points="{},{} {},{} {},{} {},{}" />
"#,
                options.branch_color,
                right_inner, top,
                right_outer, top,
                right_outer, bottom,
                right_inner, bottom,
            ));

            // Draw actual content
            for (idx, prop) in self.properties.iter().enumerate() {
                content.push_str(&format!(
                    r#"<text class="property" font-size="{}px" x="{}" y="{}">{}</text>
"#,
                    options.prop_font_size,
                    xpos,
                    depth + options.property_space * (idx + 1) as f32,
                    &prop
                ));
            }
        }
        if let Some(realized) = &self.realized {
            content.push_str(&format!(
                r#"<text class="realized" font-size="{}px" x="{}" y="{}">"{}"</text>
"#,
                options.prop_font_size,
                xpos,
                depth + options.property_space * (self.properties.len() + 1) as f32,
                &realized
            ))
        }

        content.push_str(&format!("{}\n</g>", inner_content.replace('\n', "\n    ")));

        let (max_x, max_y) = iter::once((xpos, bottom))
            .chain(children.iter().map(|pd| (pd.max_x, pd.max_y)))
            .fold_first(|(accx, accy), (x, y)| (accx.max(x), accy.max(y)))
            .unwrap();

        PartialDraw {
            content,
            left_leaves,
            xpos,
            ypos: depth,
            max_x,
            max_y,
        }
    }
}

struct PartialDraw {
    /// Leaves found to the left of me
    left_leaves: usize,
    /// String content
    content: String,
    /// X-position in pixel space
    xpos: f32,
    /// Y-position in pixel space
    ypos: f32,

    max_x: f32,
    max_y: f32,
}
